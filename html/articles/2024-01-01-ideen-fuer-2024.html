<!DOCTYPE html>
<html lang="de">
    <head>
        <title>Ideen für 2024 ‒ paedubucher.ch</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="author" content="Patrick Bucher">
        <link rel="stylesheet" type="text/css" href="../style.css">
    </head>
    <body>
        <header class="backlink"><a href="../index.html">paedubucher.ch</a></header>
        <main>
            <h1 class="title">Ideen für 2024</h1>
            
            <h2 class="subtitle">Womit soll ich mich beschäftigen?</h2>
            
            <p class="author-date">Patrick Bucher, 01.01.2024</p>
            <div class="content"><p>Das neue Jahr hat angefangen, und die Gelegenheit ist gut um mir etwas Neues
vorzunehmen. Nicht einfach bloss, weil man sich Vorsätze fürs neue Jahr nimmt,
sondern weil der Jahreswechsel mit der Arbeitspause mir die Möglichkeit bietet,
über meine Prioritäten nachzudenken ‒ und auch gleich mit neuen Sachen
anzufangen.</p>
<h1>Rückblick auf 2023</h1>
<p>Auf das Jahr 2023 habe ich bereits
<a href="./2023-12-26-jahresrueckblick-2023.html">andernorts</a> ausführlich
zurückgeblickt. Hier ist die Kurzversion davon, quasi als Andockstelle für meine
neuen Ideen. Was habe ich 2023 geleistet?</p>
<ul>
<li>eine Firma gegründet</li>
<li>Ruby on Rails gelernt und es produktiv für ein Kundenprojekt eingesetzt</li>
<li>mich mit <a href="https://github.com/patrickbucher/factorizer">Nebenläufigkeit in
  Elixir</a> befasst</li>
<li>mich mit <a href="https://github.com/patrickbucher/algorithms">Algorithmen</a> in
  verschiedenen Sprachen befasst</li>
<li>mich in den LAMP-Stack und Nextcloud auf Debian GNU/Linux eingearbeitet</li>
</ul>
<h1>Ausblick auf 2024</h1>
<p>Aus diesen Projekten sind nun folgende Ideen entstanden, mit denen ich mich 2024
gründlicher befassen möchte:</p>
<ul>
<li>Programmiersprachen<ul>
<li>Erlang</li>
<li>Rust</li>
<li>Haskell</li>
<li>TypeScript</li>
<li>Shell-Skripting</li>
</ul>
</li>
<li>Technologien<ul>
<li>Ansible</li>
<li>Hugo</li>
</ul>
</li>
<li>Lektüre<ul>
<li>Software and Mind</li>
</ul>
</li>
</ul>
<p>Diese Ideen sind nicht neu; ich habe schon einmal in alle diese Themen
hineingeschaut. Wirklich sicher fühle ich mich aber in keinem dieser Bereiche.
So wird 2024 eher ein Jahr der Vertiefung als der Neuanfänge.</p>
<h2>Erlang</h2>
<p>Mit Erlang wollte ich mich schon seit dem Ende meines Informatikstudiums im
Sommer 2020 befassen. Richtig dazu gekommen bin ich nicht. Im Standardwerk von
Joe Armstrong <a href="https://pragprog.com/titles/jaerlang2/programming-erlang-2nd-edition/">Programming
Erlang</a>
war ich bislang nie über Kapitel 3 hinausgekommen. Dafür habe ich mehrmals
Elixir «angelernt» ‒ und bin dabei etwas weiter gekommen als mit Erlang.</p>
<p>Im Sommer habe ich einige Sortieralgorithmen mit Erlang umgesetzt. Dabei ist mir
das mächtige <em>Pattern Matching</em> sehr positiv aufgefallen. Längerfristig möchte
ich zwar Elixir produktiv einsetzen. Um das gründlich lernen zu können, sollte
ich mich aber zuerst mit Erlang befassen. Ich möchte wissen, was Elixir wirklich
bietet ‒ und was bereits von Erlang geboten wird.</p>
<p>Erlang ist wohl das Gegenteil von «sexy» und «trendy»: stabil, solide ‒ und
teilweise etwas umständlich. Mittlerweile habe ich die Grundlagen der
funktionalen Programmierung verinnerlicht, sodass ich mich auf die Sprache und
Technologie konzentrieren kann. Der Key-Value-Store
<a href="https://www.erlang.org/doc/man/ets.html">ETS</a> und die Datenbank
<a href="https://www.erlang.org/doc/man/mnesia.html">Mnesia</a> sind dabei interessante
Alternativen zu bekannten Technologien wie Redis und PostgreSQL. Es muss nicht
immer vom Mainstream akzeptiert sein…</p>
<p>So habe ich mich in den letzten drei Tagen durch Kapitel 1-5 in <em>Programming
Erlang</em> durchgearbeitet und möchte die Beschäftigung mit diesem Buch zu meinem
neuen «Morgenthema» machen, d.h. mich täglich als erstes nach dem Aufstehen
damit befassen, und wenn es auch nur 15 Minuten sind. Das dürfte mich das erste
Quartal 2024 beschäftigen.</p>
<p>Mit Erlang würde ich gerne einen kleinen verteilten Monitoring-Stack entwickeln,
womit sich virtuelle Maschinen überwachen lassen (Ressourcenauslastung,
Log-Ereignisse usw.). Erlang scheint mir die perfekte Technologie dafür zu sein.</p>
<h2>Rust</h2>
<p>Auch mit Rust habe ich letzten Sommer einige wenige Algorithmen umgesetzt und
diese automatisch getestet. Durch meine Beschäftigung mit der funktionalen
Programmierung komme ich mit Rust nun einigermassen zurecht. Das nötige
Hintergrundwissen zum Memory Management fehlt mir hingegen noch. Hier habe ich
zwar einiges gelesen, aber noch lange nicht alles verstanden.</p>
<p>Ich sollte noch einmal das <a href="https://doc.rust-lang.org/book/">Rust Book</a>
durcharbeiten (evtl. in der <a href="https://rust-book.cs.brown.edu/">interaktiven
Version</a> der Brown University ‒ und mir eigene
Beispiele zu den anspruchsvollen Themen machen (<em>Borrowing</em>, <em>Smart Pointers</em>,
<em>Concurrency</em>). Anschliessend sollte ich es einmal in der Praxis anwenden.
Kommandozeilenwerkzeuge oder kleinere Serveranwendungen wären passende Projekte,
auch wenn mir hierzu im Moment noch die Ideen fehlen.</p>
<h2>Haskell</h2>
<p>Haskell gehörte <em>nicht</em> zu den Programmiersprachen, mit denen ich letzten Sommer
im Rahmen meines abgebrochenen Algorithmen-Projekts befasst habe. Doch
kombiniert die Sprache genau die Vorteile der dort verwendeten Sprachen: Haskell
ist ausdrucksstark, funktional und als kompilierte Sprache sehr performant.</p>
<p>Grundlegende Konzepte wie die IO-Monade verstehe ich mittlerweile. Trotzdem
sollte ich mich wohl parallel zur Beschäftigung mit der Sprache auch mit der
Kategorientheorie befassen.</p>
<p>Was Haskell-Literatur betrifft, bin ich mittlerweile sehr gut ausgerüstet:</p>
<ul>
<li><a href="https://pragprog.com/titles/rshaskell/effective-haskell/">Effective Haskell</a></li>
<li><a href="https://www.cs.nott.ac.uk/~pszgmh/pih.html">Programming in Haskell</a></li>
<li><a href="https://www.cambridge.org/us/universitypress/subjects/computer-science/programming-languages-and-applied-logic/thinking-functionally-haskell">Thinking Functionally with Haskell</a></li>
<li><a href="https://www.cambridge.org/us/universitypress/subjects/computer-science/algorithmics-complexity-computer-algebra-and-computational-g/algorithm-design-haskell">Algorithm Design with Haskell</a></li>
<li><a href="https://www.blurb.com/b/9621951-category-theory-for-programmers-new-edition-hardco">Category Theory for Programmers</a></li>
</ul>
<p>So werde ich wohl <em>Effective Haskell</em> und <em>Category Theory for Programmers</em>
parallel durcharbeiten. <em>Programming in Haskell</em> habe ich schon zweimal bis zur
Hälfte durchgearbeitet und könnte ich anschliessend als Repetition
durcharbeiten. <em>Thinking Functionally in Haskell</em> und <em>Algorithm Design with
Haskell</em> wären dann eine Vertiefung in die funktionale Programmierung und in
Algorithmen.</p>
<h2>TypeScript</h2>
<p>Ich habe schon mehrere halbherzige Versuche unternommen Angular zu lernen. Zwar
könnte ich dieses Web-Framework sicherlich produktiv einsetzen und damit Geld
verdienen, die Motivation zum Durchhalten fehlte mir aber bislang.</p>
<p>TypeScript gründlich zu lernen wäre einerseits schon ein grosser Schritt in
Richtung Angular. Ausserdem würde ich dabei mein bestehendes und eingerostetes
JavaScript-Wissen auffrischen ‒ und mein Wissen über Typsysteme vertiefen
können. Das sollte für mich genügend Motivation sein um dranzubleiben.</p>
<p>Mit dem ganzen TypeScript-Wissen sollte ich mir Angular dann durch das Lesen von
bestehendem Code aneignen können. (Bücher und Kurse über moderne Web-Frameworks
sind praktisch schon beim Erscheinen veraltet und darum teilweise frustrierend
beim Durcharbeiten, zumal vieles einfach nicht wie beschrieben funktioniert.)</p>
<p>Ob ich mich dann wirklich mit Angular befassen möchte, ist eine andere Frage.
TypeScript wird mir auf jeden Fall nicht schaden, sondern eröffnet mir auch die
Möglichkeit, mich mit anderen Web-Frameworks zu befassen. Mit <a href="https://www.manning.com/books/essential-typescript-5-third-edition">Essential
TypeScript</a>
hätte ich schon das passende Buch auf Lager. (Wobei «essential» und 568
Druckseiten mir doch ein etwas mulmiges Gefühl bereiten…)</p>
<h2>Shell-Skripting</h2>
<p>Zwar ist die Kommandozeile seit meinem Umstieg auf
<a href="http://dwm.suckless.org/">dwm</a> im Jahr 2010 meine primäre Benutzeroberfläche
geworden. Mein Wissen beschränkt sich aber auf die alltägliche Bedienung; sobald
es um das Schreiben anspruchsvollerer Skripte geht, stehe ich recht schnell an.</p>
<p>So möchte ich gelegentlich mein Wissen der Unix-Shell etwas vertiefen. Da mir
Portabilität ‒ gerade im Hinblick auf OpenBSD und FreeBSD, welche <em>nicht</em> die
Bash als Standard-Shell verwenden ‒ sehr wichtig ist, möchte ich mich aber auf
eine möglichst POSIX-kompatible Untermenge von Shell-Mechanismen beschränken.</p>
<p>Die Korn-Shell, die bei OpenBSD als <code>pdksh</code> zum Einsatz kommt, wäre hierzu eine
interessante Variante und würde mir auch den Wiedereinstieg in OpenBSD
ermöglichen. Mit <a href="https://www.oreilly.com/library/view/learning-the-korn/0596001959/">Learning the Korn
Shell</a> steht
auch das passende Buch dazu schon bereit. (Es ist aus dem Jahr 2002 ‒ als
O'Reilly noch für Qualität und Nerd-Kultur stand.)</p>
<p>Sollte ich noch Zeit haben, könnte ich mich dann gleich noch mit der zweiten
Ausgabe von <a href="https://www.informit.com/store/awk-programming-language-9780138269722">The AWK Programming
Language</a>
in AWK vertiefen. So ein gutes Nutzen-Aufwand-Verhältnis wird mir sonst keines
der 2024 angestrebten Lernprojekte bieten.</p>
<h2>Ansible</h2>
<p>Seit Ende Juni habe ich nichts mehr mit Konfigurationsmanagementwerkzeugen zu
tun. Puppet vermisse ich überhaupt nicht, doch werde ich dieses Jahr wohl
endlich Zeit dafür haben um Infrastruktur für die eigene Firma aufzubauen. Und
hierzu bietet sich Ansible an.</p>
<p>Ansible möchte ich bereits schon im Januar im Berufsschulunterricht verwenden,
um damit die Installation von Nextcloud (zumindest teilweise) zu automatisieren.
So werde ich mir die Grundlagen davon recht pragmatisch und schnell aneignen
müssen. Eine Vertiefung erfolgt dann, wenn ich Zeit dafür und den Bedarf danach
habe.</p>
<p>Eine Schnellbleiche bietet mir <a href="https://nostarch.com/devops-desperate">DevOps for the
Desperate</a>. Vertiefen werde ich es dann
mit <a href="https://leanpub.com/ansible-for-devops">Ansible for DevOps</a>. («DevOps» wird
offenbar beidenorts als Marketing-Begriff missbraucht, zumal Ansible in erster
Linie ein Werkzeug für «Ops» ist.)</p>
<h2>Hugo</h2>
<p>Die Umstellung von meiner eigenen Webseite auf <a href="https://gohugo.io/">Hugo</a> ist
zwar vorletztes Jahr vorerst gescheitert, zumal die einfachsten Hugo-Templates
mehr bieten, als ich für meine Webseite benötige. Für eine Firmenwebseite ‒
<a href="https://www.composed.ch">composed.ch</a> ist derzeit ein blosser Platzhalter ‒
könnte Hugo aber genau das Richtige sein.</p>
<p>So sollte ich mich endlich einmal in diese Technologie einarbeiten.
Grundsätzlich besteht bei Hugo ein «Henne-Ei-Problem»: Man benötigt zuerst ein
Template, um vernünftig mit Hugo herumspielen zu können. Zum Nachvollziehen der
Funktionsweise von Hugo sollte man aber andererseits auch eigene Templates
schreiben können. So werde ich wohl versuchen, zuerst eine Seite mit einem
Standard-Template zu bauen. Anschliessend baue ich mir ein eigenes Template, bis
die damit erstellte Seite komplett funktioniert.</p>
<p>Da mich <a href="https://pragprog.com/titles/bhhugo/build-websites-with-hugo/">Build Websites with
Hugo</a> eher
enttäuscht hat, mache ich den nächsten Versuch mit <a href="https://www.manning.com/books/hugo-in-action">Hugo in
Action</a>.</p>
<h2>Software and Mind</h2>
<p>Auf das Mammutwerk <a href="http://softwareandmind.com/">Software and Mind</a> bin ich
schon vor einigen Jahren auf der Suckless-Mailingliste aufmerksam gemacht
worden. Zwar hat mich die grundsätzliche Skepsis Mainstream-Paradigmen gegenüber
angesprochen ‒ der Gegenentwurf des Autors (ein
<a href="http://softwareandmind.com/#IFOP">COBOL-Programm</a> bestehend aus einer 50'000
zeiligen Quellcodedatei) hat mich aber eher irritiert. So habe ich mich nicht
weiter mit Andrei Sorins Ideen befasst.</p>
<p>Aus einer Frustration mit Mainstream-Technologien habe ich das Buch zum
Jahresende aber erneut angelesen ‒ und war über die darin geäusserte (teilweise
fundamentale) Kritik regelrecht begeistert! Dass Sorin Paradigmen wie
relationale Datenbanken und strukturierte Programmierung als fehlgeleitet
kritisiert, irritiert mich zwar gewaltig, zumal ich niemals gedacht hätte,
«hinter» diese Paradigmen zurückzugehen. Andererseits wird einem gerade
hierdurch eine neue Perspektive eröffnet. (Die Kritik am objektorientierten
Paradigma dürfte für mich hingegen eher eine Bestätigung als eine
Infragestellung sein.)</p>
<p>Sorin bezeichnet die etablierten Paradigmen als unwissenschaftlich, was er
mithilfe von Poppers Demarkationsbegriff ausführlich zu begründet versucht.
Damit ich diese Gedanken nachvollziehen kann, muss ich mir zunächst <a href="https://www.routledge.com/The-Logic-of-Scientific-Discovery/Popper-Popper/p/book/9780415278447">The Logic
of Scientific
Discovery</a>
durchlesen. Erst dann kann ich mich gründlich mit <em>Software and Mind</em> befassen.</p>
<hr>
<p>Sollte ich mich 2024 tatsächlich an diesen Plan halten können, dürfte das ein
sehr lehrreiches Jahr sein!</p></div>
        </main>
        <footer class="backlink"><a href="index.html">© 2023 by Patrick Bucher</footer>
    </body>
</html>