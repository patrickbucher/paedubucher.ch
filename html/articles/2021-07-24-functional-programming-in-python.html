<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Functional Programming in Python ‒ paedubucher.ch</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="author" content="Patrick Bucher">
        <link rel="stylesheet" type="text/css" href="../style.css">
    </head>
    <body>
        <div class="backlink"><a href="../index.html">paedubucher.ch</a></div>
        <h1 class="title">Functional Programming in Python</h1>
        
        <h2 class="subtitle">Concepts and Examples</h2>
        
        <h3 class="author">Patrick Bucher</h3>
        <h3 class="date">2021-07-24</h3>
        <div class="content"><p>This overview is inspired by <a href="https://leanpub.com/functionalprogramminginpython">Functional Programming in
Python</a> by Martin McBride.</p>
<h1>Introduction</h1>
<p>Python supports three major programming paradigms:</p>
<ul>
<li>Procedural Programming: Code is structured in blocks (functions, loops, if
  statements); simple, but hard to maintain big code bases.</li>
<li>Object Oriented Programming (OOP): Code is structured in interacting objects;
  this encapsulation makes independent testing easier, the approach scales
  better to larger code bases.</li>
<li>Functional Programmnig (FP): Functions are used as the main building block;
  a declarative rather than imperative programming style is used.</li>
</ul>
<p>Those paradigms are usually mixed; however, FP is often neglected.</p>
<h2>Functional Concepts</h2>
<p>In FP, functions are <em>first class objects</em>: They can be stored in variables,
passed to other functions as parameters, or be returned from functions.</p>
<p>Functions that operate on functions are called <em>higher order functions</em>.</p>
<p>A <em>pure function</em> calculates a result without any side effects. Its result only
depends on the input parameters, not on global state. Neither is global state
changed. A pure function called multiple times with the same arguments always
returns the same result.</p>
<p>FP fits well together with immutable objects such as strings and tuples.
Iterators, which do not allow for modification, but for <em>lazy evaluation</em>, are
often preferred over lists.</p>
<p>Higher order functions (<code>filter</code>, <code>map</code>, <code>apply</code>) and recursion are preferred
over structural constructs (<code>if</code>/<code>else</code> branching, loops).</p>
<p>New functions are created dynamically by combining existing functions.</p>
<h2>Pros and Cons</h2>
<p>FP has a lot of <em>advantages</em>:</p>
<ul>
<li>Conciseness: more can be expressed in less lines of code thanks to more
  abstract constructs</li>
<li>Clarity: the programmer's intention is put across better by using higher-order
  functions like <code>map</code> than loop constructs that have to be deciphered line by
  line</li>
<li>Provability: without side effects, reasoning about programs is easier;
  mathematical correctness proofs become <em>possible</em></li>
<li>Concurrency: without side effects, functions can be executed independently and
  in parallel and won't cause race conditions</li>
</ul>
<p>However, this comes with some <em>disadvantages</em>:</p>
<ul>
<li>Purity is often not possible, because the purpose of many programs is to
  change global state. A line between pure and impure code has to be drawn.</li>
<li>A lot of learning effort is required to understand functional concepts such as
  lambda expressions, closures, partial functions, currying etc.</li>
<li>Functional code can be less efficient than structured code due to constructs
  that are less efficient (recursion instead of loops) or more expensive
  (re-building data structures instead of modifying them).</li>
</ul>
<h1>Functions as Objects</h1>
<p>Functions can be stored in variables like, say, a string:</p>
<pre class="codehilite"><code class="language-python">name = 'Dilbert'

employee = name

def say_hi(name):
    return f'Hello, {name}'

greet = say_hi

print(name)
print(employee)
print(say_hi)
print(greet)</code></pre>


<p>There are two variables (<em>aliases</em>) pointing to the same object in memory:</p>
<pre class="codehilite"><code>Dilbert
Dilbert
&lt;function say_hi at 0x7f955db5b040&gt;
&lt;function say_hi at 0x7f955db5b040&gt;</code></pre>


<p>It's also possible (but hardly advisable) to overwrite a function reference:</p>
<pre class="codehilite"><code class="language-python">def greet(name):
    return f'Hello, {name}'

def say_hi(name):
    return greet(name)

print(say_hi('Dilbert'))

def greet(name):
    return f'Greetings, {name}'

print(say_hi('Wally'))</code></pre>


<p>After overwriting the <code>greet</code> function, the second implementation is called:</p>
<pre class="codehilite"><code>Hello, Dilbert
Greetings, Wally</code></pre>


<p>The implementation of <code>say_hi</code> function has been modified indirectly, which
could introduce subtle bugs.</p>
<p>Consider the following conversion functions:</p>
<pre class="codehilite"><code class="language-python">def miles_to_kilometers(miles):
    return miles / 1.60934

def usd_to_chf(usd):
    return usd / 0.92

print('500 miles =', miles_to_kilometers(500), 'km')
print('100 usd =', usd_to_chf(100), 'chf')</code></pre>


<p>Which perform their conversion independently:</p>
<pre class="codehilite"><code>500 miles = 310.68636832490336 km
100 usd = 108.69565217391303 chf</code></pre>


<p>However, both functions implement the same conversion mechanism, which can be
generalized:</p>
<pre class="codehilite"><code class="language-python">def convert(f, x):
    return f(x)

print('500 miles =', convert(miles_to_kilometers, 500), 'km')
print('100 usd =', convert(usd_to_chf, 100), 'chf')</code></pre>


<p>Both a function and a number are passed to <code>convert</code>, which then applies the
function to the number. Any conversion can be made, also between different
types:</p>
<pre class="codehilite"><code class="language-python">def format_currency(x):
    return f'{x:.2f}'

convert(format_currency, 10/3)  # '3.33 chf'</code></pre>


<h2>Sorting</h2>
<p>The built-in <code>sorted</code> function accepts an optional <code>key</code> function that allows
for customized sorting:</p>
<pre class="codehilite"><code class="language-python">dilbert = ('Dilbert', 42)
alice = ('Alice', 37)
dogbert = ('Dogbert', 7)
ashok = ('Ashok', 21)

employees = [dilbert, alice, dogbert, ashok]

def get_name(employee):
    return employee[0]

def get_age(employee):
    return employee[1]

by_name = sorted(employees, key=get_name)
by_age = sorted(employees, key=get_age)

print(by_name)
print(by_age)</code></pre>


<p>The list of employees is sorted twice: once by name, and once by age:</p>
<pre class="codehilite"><code>[('Alice', 37), ('Ashok', 21), ('Dilbert', 42), ('Dogbert', 7)]
[('Dogbert', 7), ('Ashok', 21), ('Alice', 37), ('Dilbert', 42)]</code></pre>


<h2>Lambdas</h2>
<p>The code can be shortened by using unnamed <em>lambda functions</em>:</p>
<pre class="codehilite"><code class="language-python">by_name = sorted(employees, key=lambda e: e[0])
by_age = sorted(employees, key=lambda e: e[1])</code></pre>


<p>Lambdas consist of a single expression and, thus, should only be used for very
simple computations that can be clearly understood without a function name or
additional comments. Use a regular function if an expression is used more than
once.</p>
<p>Lambdas are function objects that can also be called directly:</p>
<pre class="codehilite"><code class="language-python">&gt;&gt;&gt; (lambda x: x ** 2)(5)
24</code></pre>


<p>More practically, they can be returned from functions:</p>
<pre class="codehilite"><code class="language-python">def create_increment_function(step=1):
    return lambda x: x + step

add_one = create_increment_function()
add_two = create_increment_function(step=2)

add_one(5)  # 5
add_two(5)  # 7</code></pre>


<p>Operators are not functions, but can be wrapped in lambda expressions for use
with higher-order functions:</p>
<pre class="codehilite"><code class="language-python">def calculate(op, a, b):
    return op(a, b)

calculate(lambda a, b: a + b, 3, 1)  # 4
calculate(lambda a, b: a * b, 3, 2)  # 6</code></pre>


<h2>Operator Functions</h2>
<p>The <code>operator</code> module contains pre-defined functions for common operators, so no
lambdas have to be implemented:</p>
<pre class="codehilite"><code class="language-python">import operator

def calculate(op, a, b):
    return op(a, b)

calculate(operator.add, 3, 1)  # 4
calculate(operator.mul, 3, 2)  # 6</code></pre>


<p>See the <a href="https://docs.python.org/3/library/operator.html#mapping-operators-to-functions">documentation of the <code>operator</code>
module</a>
for a full list of operators and their function equivalents.</p>
<h2>Partial Function Application</h2>
<p>Functions can be <em>partially applied</em>, i.e. called with fewer arguments than
expected, which returns a function only expecting the missing arguments:</p>
<pre class="codehilite"><code class="language-python">from functools import partial

def f(a, b, c, x):
    return a * x**2 + b * x + c

f(2, 4, 6, 1)  # x=1: 2x² + 4x + 6 = 12

g = partial(f, 2, 4, 6)
g(1)   # x=1: 2x² + 4x + 6 = 12
g(2)   # x=2: 2x² + 4x + 6 = 22</code></pre>


<h1>Mutability</h1>
<p>Lists, dictionaries, and sets are <em>mutable</em>; numbers, strings, and tuples are
<em>immutable</em>. A frozen set is an immutable version of a set. References to any of
those objects are always mutable: by re-assigning a variable, the object pointed
to is <em>not changed</em>, but <em>another object</em> is pointed to instead.</p>
<p>Notice that mutability is shallow. A tuple itself cannot be modified, but the
elements of a tuple containing of lists can be modified.</p>
<p>The <code>sort</code> method of a list modifies the underlying list, whereas the <code>sorted</code>
function returns a sorted copy of the given list.</p>
<p>A list can be copied by passing it to the <code>list</code> function:</p>
<pre class="codehilite"><code class="language-python">def tail(l):
    del l[0]
    return l

numbers = [1, 2, 3]
print(tail(numbers))  # [2, 3]
print(numbers)        # [2, 3], too (modified)

numbers = [1, 2, 3]
print(tail(list(numbers)))  # [2, 3]
print(numbers)              # [1, 2, 3], still (unmodified)</code></pre>


<p>This, however, is very inefficient. Instead, the <code>tail</code> function could work with
slicing to guarantee immutability:</p>
<pre class="codehilite"><code class="language-python">def tail(l):
    return l[1:]

numbers = [1, 2, 3]
print(tail(numbers))  # [2, 3]
print(numbers)        # [1, 2, 3], still (unmodified)</code></pre>


<p>Under the hood, slicing is copying, so this solution is not very efficient, too.</p>
<p>Modifications that affect every single item of a list can be expressed using
<em>list comprehensions</em>:</p>
<pre class="codehilite"><code class="language-python">numbers = [1, 2, 3]
twice = [x * 2 for x in numbers]
print(twice)  # [2, 4, 6]</code></pre>


<h1>Recursion</h1>
<p>Functions that call themselves are a common technique in functional programming.
A problem is thereby reduced to its base case, which is defined statically. In
the general case, a problem is simplified towards the base case:</p>
<pre class="codehilite"><code class="language-python">def factorial(n):
    if n == 0:
        return 1
    elif n &gt; 0:
        return n * factorial(n - 1)

print(factorial(2))  # 2
print(factorial(3))  # 6
print(factorial(4))  # 24</code></pre>


<p>The bigger the argument <code>n</code> is chosen, the more functions are running at the
same time:</p>
<pre class="codehilite"><code>factorial(6)
6 * factorial(5)
6 * 5 * factorial(4)
6 * 5 * 4 * factorial(3)
6 * 5 * 4 * 3 * factorial(2)
6 * 5 * 4 * 3 * 2 * factorial(1)
6 * 5 * 4 * 3 * 2 * 1 factorial(0)
6 * 5 * 4 * 3 * 2 * 1 * 1
6 * 5 * 4 * 3 * 2 * 1
6 * 5 * 4 * 3 * 2
6 * 5 * 4 * 6
6 * 5 * 24
6 * 120
720</code></pre>


<p>This doesn't scale well. An alternative approach to recursive functions are
tail-recursive functions, which carry intermediate results as an extra
accumulator parameter (<code>acc</code>):</p>
<pre class="codehilite"><code class="language-python">def factorial(n, acc=1):
    if n == 0:
        return acc
    elif n &gt; 0:
        return factorial(n-1, n * acc)</code></pre>


<p>Which leads to an easier to understand call stack:</p>
<pre class="codehilite"><code>factorial(6, 1)
factorial(5, 6)
factorial(4, 30)
factorial(3, 120)
factorial(2, 360)
factorial(1, 720)
factorial(0, 720)
720</code></pre>


<h2>(No) Tail Call Optimization</h2>
<p>Some compilers are able to optimize tail-recursive functions by re-using stack
frames for multiple function calls. Unfortunately, Python doesn't support this
optimization, so other solutions needs to be considered, such as loops.</p>
<p>Recursion becomes even more inefficient as multiple additional functions are
called in each step, as a recursive implementation of a function to compute the
Fibonacci numbers requires:</p>
<pre class="codehilite"><code class="language-python">def fib(n):
    print(f'fib({n})')
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-2) + fib(n-1)</code></pre>


<p>The <code>print</code> call makes the amount of (redundant) functions being called
apparent:</p>
<pre class="codehilite"><code>&gt;&gt;&gt; fib(6)
fib(6)
fib(4)
fib(2)
fib(0)
fib(1)
fib(3)
fib(1)
fib(2)
fib(0)
fib(1)
fib(5)
fib(3)
fib(1)
fib(2)
fib(0)
fib(1)
fib(4)
fib(2)
fib(0)
fib(1)
fib(3)
fib(1)
fib(2)
fib(0)
fib(1)
8</code></pre>


<p>The <code>fib</code> function is called with the argument <code>1</code> alone eight times. The
inefficiency becomes even more striking when using a bigger <code>n</code> and counting the
function calls (<code>fibonacci.py</code>):</p>
<pre class="codehilite"><code class="language-python">calls = 0

def fib(n):
    global calls
    calls += 1
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-2) + fib(n-1)

print(f'fib(35)={fib(35)} after {calls} calls')</code></pre>


<p>Almost 30 million function calls in a bit less than five seconds are required to
compute the 35th Fibonacci number:</p>
<pre class="codehilite"><code class="language-bash">$ time python3 fibonacci.py
fib(35)=9227465 after 29860703 calls

real    0m4.948s
user    0m4.946s
sys     0m0.000s</code></pre>


<h2>Memoization</h2>
<p>When many intermediate results are computed multiple times, re-using those
results helps saving function calls. For this purpose, the function arguments
are (keys) are put together with the results (values) into a dictionary. This
technique is called <em>memoization</em>:</p>
<pre class="codehilite"><code class="language-python">calls = 0
cache = {}

def fib(n):
    global calls
    calls += 1
    if n in cache:
        return  cache[n]
    else:
        if n == 0:
            result = 0
        elif n == 1:
            result = 1
        else:
            result = fib(n-2) + fib(n-1)
        cache[n] = result
        return result

print(f'fib(35)={fib(35)} after {calls} calls')</code></pre>


<p>Which reduces function calls by a factor of more than 4*10^5, and runtime by a
factor of roughly 167 (memoization comes with a slight overhead).</p>
<pre class="codehilite"><code class="language-bash">fib(35)=9227465 after 69 calls

real    0m0.030s
user    0m0.030s
sys     0m0.000s</code></pre>


<p>Memoization is a <em>cross cutting concern</em> that has little to do with the function
itself. Python's <code>functools</code> has a decorator <code>lru_cache</code> (least recently used
cache) which provides memoization out-of-the-box:</p>
<pre class="codehilite"><code class="language-python">from functools import lru_cache

calls = 0

@lru_cache
def fib(n):
    global calls
    calls += 1
    if n == 0:
        result = 0
    elif n == 1:
        result = 1
    else:
        result = fib(n-2) + fib(n-1)
    return result

print(f'fib(35)={fib(35)} after {calls} calls')</code></pre>


<p>Even less functions are invoked, because the caching mechanism is around the
function:</p>
<pre class="codehilite"><code class="language-bash">fib(35)=9227465 after 36 calls

real    0m0.029s
user    0m0.025s
sys     0m0.004s</code></pre>


<h2>Flattening Lists</h2>
<p>Lists in Python can be nested:</p>
<pre class="codehilite"><code class="language-python">[1, [2, [3, 4, [5, 6], 7], 8], 9]</code></pre>


<p>Such a list contains numbers and lists, which again contain numbers and lists,
and so on. It is often useful to <em>flatten</em> such a list:</p>
<pre class="codehilite"><code class="language-python">[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>


<p>For this purpose, a recursive implementation processes the nested list one by
one. The first element (<code>head</code>) of the remaining list is considered in each
function call, and the remaining elements (<code>tail</code>) are delegated to another
recursive call. Then, the solution is combined:</p>
<pre class="codehilite"><code class="language-python">def flatten(x):
    if not isinstance(x, list):
        # x is a number: first base case
        return [x]
    if x == []:
        # x is an empty list: second base case
        return x
    else:
        # x is a non-empty list: general case
        return flatten(x[0]) + flatten(x[1:])</code></pre>


<p>Memoization won't help here, because <code>x</code> is different for every function call. A
more feasible approach would be to fall back to loops:</p>
<pre class="codehilite"><code class="language-python">def flatten(x):
    if not isinstance(x, list):
        # x is a number: first base case
        return [x]
    if x == []:
        # x is an empty list: second base case
        return x
    else:
        # x is a non-empty list: general case
        r = []
        for e in x:
            if isinstance(e, list):
                r += flatten(e)
            else:
                r.append(e)
        return r</code></pre>


<p>A recursive function call here only takes place for each additional depth level,
not for every additional element.</p>
<h1>Closures</h1>
<p>Functions can contain other functions. The inner function cannnot be seen from
the outside of the outer function, unless the outer function returns the inner
function. In this example, an inner function <code>grade</code> is used from the outer
function <code>grade_exams</code>.</p>
<pre class="codehilite"><code class="language-python">def grade_exams(candidate_scores, max_score):

    def grade(score):
        # Swiss grades: 1..6
        return score / max_score * 5 + 1

    candidate_grades = {}
    for candidate, score in candidate_scores.items():
        candidate_grades[candidate] = grade(score)

    return candidate_grades

exam_max_score = 50
exam_scores = {
    'Alice': 42,
    'Bob': 35,
    'Mallory': 49,
}
exam_grades = grade_exams(exam_scores, exam_max_score)
print(exam_grades) # {'Alice': 5.2, 'Bob': 4.5, 'Mallory': 5.9}</code></pre>


<h2>Returning Inner Functions</h2>
<p>Notice how each <code>score</code> is passed to <code>grade</code>, but <code>max_score</code> is taken from the
outer scope. The inner function even has access to the outer function's scope if
it is returned from the outer function and used elsewhere. The outer function
<em>encloses</em> the inner function; this construct therefore is called a <em>closure</em>:</p>
<pre class="codehilite"><code class="language-python">def get_compute_salary_func(year):

    bonus_rates = {
        2018: 0.05,
        2019: 0.10,
        2020: 0.07,
    }
    bonus_rate = bonus_rates.get(year, 0.0)

    def compute_yearly_salary(monthly):
        base_salary = monthly * 12
        bonus = base_salary * bonus_rate
        return base_salary + bonus

    return compute_yearly_salary

compute_2016_salaries = get_compute_salary_func(2016)
compute_2018_salaries = get_compute_salary_func(2018)
compute_2020_salaries = get_compute_salary_func(2020)

print(compute_2016_salaries(80000))  #  960000.0
print(compute_2018_salaries(80000))  # 1008000.0
print(compute_2020_salaries(80000))  # 1027200.0</code></pre>


<p>In the example above, the outer function <code>get_compute_salary_func</code> encloses the
inner function <code>compute_yearly_salary</code>; the latter using the variable
<code>bonus_rate</code> established in the former's scope. Even though the same function is
used multiple times, it computes different results, because the enclosing scope
is different.</p>
<h2>Map</h2>
<p>A dictionary is a Python data structure that describes the relationship between
a key and a value in a static way. The <code>map</code> function can be seen as the dynamic
counterpart of a <code>dict</code>. It is a higher-order function that processes a
collection of items using a given function, and returns a collection consisting
of the function's return value for each item:</p>
<pre class="codehilite"><code class="language-python">max_score = 50
exam_scores = [42, 35, 49]

def grade(score):
    # Swiss grades: 1..6
    return score / max_score * 5 + 1

exam_grades = map(grade, exam_scores)
print(list(exam_grades))  # [5.2, 4.5, 5.9]</code></pre>


<p>No explicit looping over the individual scores is needed, the <code>map</code> function
handles those details. The code can be further simplified by using a lambda
instead of a named function:</p>
<pre class="codehilite"><code class="language-python">max_score = 50
exam_scores = [42, 35, 49]
exam_grades = map(lambda score: score / max_score * 5 + 1, exam_scores)
print(list(exam_grades))</code></pre>


<p>This works with any kind of functions, i.e. also with a closure <em>primed</em> with
a value, like in the salary example from before:</p>
<pre class="codehilite"><code class="language-python">def get_compute_salary_func(year):

    bonus_rates = {
        2018: 0.05,
        2019: 0.10,
        2020: 0.07,
    }
    bonus_rate = bonus_rates.get(year, 0.0)

    def compute_yearly_salary(monthly):
        base_salary = monthly * 12
        bonus = base_salary * bonus_rate
        return base_salary + bonus

    return compute_yearly_salary

compute_2020_salaries = get_compute_salary_func(2020)
base_salaries = [80000, 90000, 100000]
total_salaries = map(compute_2020_salaries, base_salaries)
print(list(total_salaries))</code></pre>


<h2>Composing Functions</h2>
<p>Consider the value <code>x</code> that has to be processed by two functions <code>f</code> and <code>g</code>:</p>
<ol>
<li><code>y</code> is computed as <code>y=g(x)</code> (intermediate result)</li>
<li><code>z</code> is computed as <code>z=f(y)</code> (final result)</li>
</ol>
<p>This, of course, can be simplified by <em>composing</em> the two functions <code>f</code> and <code>g</code>
as <code>f(g(x))</code>.</p>
<p>Consider this example, where exam scores are first mapped to exam grades, which
then are rounded in a second step:</p>
<pre class="codehilite"><code class="language-python">def get_grade_for_func(max_score):

    def grade(score):
        return score / max_score * 5 + 1

    return grade

def get_round_to_func(granularity):

    def round_to(value):
        scaled_up = value * (1 / granularity)
        rounded = round(scaled_up)
        scaled_down = rounded * granularity
        return scaled_down

    return round_to

max_score = 72
scores = [46, 70, 53, 38, 67]

grade_for = get_grade_for_func(max_score)
round_to = get_round_to_func(0.1)

exact_grades = map(grade_for, scores)
rounded_grades = map(round_to, exact_grades)

print(list(rounded_grades))  # [4.2, 5.9, 4.7, 3.6, 5.7]</code></pre>


<p>This approach requires two calls to <code>map</code>, with each call iterating over all the
elements. If the grader and rounding function are composed to a single function,
the list only needs to be processed once:</p>
<pre class="codehilite"><code class="language-python">def get_grade_for_func(max_score):

    def grade(score):
        return score / max_score * 5 + 1

    return grade

def get_round_to_func(granularity):

    def round_to(value):
        scaled_up = value * (1 / granularity)
        rounded = round(scaled_up)
        scaled_down = rounded * granularity
        return scaled_down

    return round_to

max_score = 72
scores = [46, 70, 53, 38, 67]

grade_for = get_grade_for_func(max_score)
round_to = get_round_to_func(0.1)

def compose(f, g):

    def func(x):
        return f(g(x))

    return func

score_to_rounded_grade = compose(round_to, grade_for)

rounded_grades = map(score_to_rounded_grade, scores)

print(list(rounded_grades))  # [4.2, 5.9, 4.7, 3.6, 5.7]</code></pre>


<p>This approach scales much better: Not only in terms of runtime efficiency, which
becomes noticable as the number of elements grows, but only if additional
computations need to be done for every item.</p>
<p>In this example, an additional point bonus is added to each score, so that the
maximum grade can be reached without a perfect score:</p>
<pre class="codehilite"><code class="language-python">def get_bonus_of_func(bonus):

    def add(score):
        return score + bonus

    return add

def get_grade_for_func(max_score):

    def grade(score):
        return score / max_score * 5 + 1

    return grade

def get_round_to_func(granularity):

    def round_to(value):
        scaled_up = value * (1 / granularity)
        rounded = round(scaled_up)
        scaled_down = rounded * granularity
        return scaled_down

    return round_to

max_score = 100
scores = [70, 80, 90, 40, 100]

bonus_of = get_bonus_of_func(max_score / 10)
grade_for = get_grade_for_func(max_score)
round_to = get_round_to_func(0.1)

def compose(f, g):

    def func(x):
        return f(g(x))

    return func

score_to_exact_grade = compose(grade_for, bonus_of)
score_to_rounded_grade = compose(round_to, score_to_exact_grade)

rounded_grades = map(score_to_rounded_grade, scores)

print(list(rounded_grades))  # [5.0, 5.5, 6.0, 3.5, 6.5]</code></pre>


<p>Unfortunately, this brings up another issues: Grades higher than the maximum
grade of 6.0 are computed. However, this issues can be solved by composing even
further:</p>
<pre class="codehilite"><code class="language-python">def get_bonus_of_func(bonus):

    def add(score):
        return score + bonus

    return add

def get_grade_for_func(max_score):

    def grade(score):
        return score / max_score * 5 + 1

    return grade

def get_limit_of_func(max_grade):

    def limit(grade):
        return min(grade, max_grade)

    return limit


def get_round_to_func(granularity):

    def round_to(value):
        scaled_up = value * (1 / granularity)
        rounded = round(scaled_up)
        scaled_down = rounded * granularity
        return scaled_down

    return round_to

max_score = 100
scores = [70, 80, 90, 40, 100]

bonus_of = get_bonus_of_func(max_score / 10)
grade_for = get_grade_for_func(max_score)
limit_of = get_limit_of_func(6.0)
round_to = get_round_to_func(0.1)

def compose(f, g):

    def func(x):
        return f(g(x))

    return func

score_to_exact_grade = compose(grade_for, bonus_of)
score_to_bounded_grade = compose(limit_of, score_to_exact_grade)
score_to_rounded_grade = compose(round_to, score_to_bounded_grade)

rounded_grades = map(score_to_rounded_grade, scores)

print(list(rounded_grades))  # [5.0, 5.5, 6.0, 3.5, 6.0]</code></pre>


<p>Compare this to a procedural approach, which is much shorter in terms of lines:</p>
<pre class="codehilite"><code class="language-python">max_score = 100
scores = [70, 80, 90, 40, 100]
bonus = max_score / 10
max_grade = 6.0
granularity = 0.1

grades = []
for score in scores:
    score = score + bonus
    grade = score / max_score * 5 + 1
    if grade &gt; max_grade:
        grade = max_grade
    grade = round(grade * 1 / granularity) * granularity
    grades.append(grade)

print(grades)  # [5.0, 5.5, 6.0, 3.5, 6.0]</code></pre>


<p>However, this code is harder to reason about ("Where did the error happen?"),
especially if the computations are getting more involved. The functional
approach allows you to reason about and write tests for each function in
isolation. If the functions work correctly, are composed in the right way and
used with well-tested higher-order functions like <code>map</code> , the result will be
correct, too.</p>
<h2>Closures vs. Classes</h2>
<p>Like objects, closures can hold state. In OOP, the state can be initialized
using a constructor. A method of the same class then can perform computations
based on both internal state and parameters:</p>
<pre class="codehilite"><code class="language-python">class Rounder:

    def __init__(self, granularity):
        self._granularity = granularity

    def round(self, value):
        scaled_up = value * (1 / self._granularity)
        rounded = round(scaled_up)
        scaled_down = rounded * self._granularity
        return scaled_down

grades = [5.234, 4.738, 3.269]
rounder = Rounder(0.05)
rounded = map(rounder.round, grades)
print(list(rounded))  # [5.25, 4.75, 3.25]</code></pre>


<p>Python has a special method <code>__call__</code>, which allows objects to be used like
functions. The above implementation can be turned more pythonesque by, first,
renaming <code>round</code> to <code>__call__</code>, and, second, by using <code>rounder</code> as a function
(instead of its method <code>rounder.round</code>). Calls to <code>rounder()</code> will be delegated
to the <code>__call__</code> method:</p>
<pre class="codehilite"><code class="language-python">class Rounder:

    def __init__(self, granularity):
        self._granularity = granularity

    def __call__(self, value):
        scaled_up = value * (1 / self._granularity)
        rounded = round(scaled_up)
        scaled_down = rounded * self._granularity
        return scaled_down

grades = [5.234, 4.738, 3.269]
rounder = Rounder(0.05)
rounded = map(rounder, grades)
print(list(rounded))  # [5.25, 4.75, 3.25]</code></pre>


<p>This approach is useful when objects first need to be configured in a
complicated but inconsistent manner. Think of the Builder pattern, that allows
to initialize objects only using a subset of available parameters:</p>
<pre class="codehilite"><code class="language-python">class Salary:

    _bonus = 0
    _taxes = 0
    _penalty = 0

    def __init__(self, amount):
        self._salary = amount

    def with_bonus(self, rate):
        self._bonus = rate
        return self

    def with_taxes(self, rate):
        self._taxes = rate
        return self

    def with_penalty(self, penalty):
        self._penalty = penalty
        return self

    def __call__(self):
        pre_bonus = (self._salary - self._penalty)
        pre_taxes = pre_bonus + pre_bonus * self._bonus
        return pre_taxes - pre_taxes * self._taxes

salary_1 = Salary(100000).with_bonus(0.1).with_penalty(5000)
salary_2 = Salary(100000).with_bonus(0.1).with_taxes(0.2)
print(salary_1())  # 104500.0
print(salary_2())  #  88000.0</code></pre>


<p>A function returning a closure requires optional parameters for the same
purpose:</p>
<pre class="codehilite"><code class="language-python">def get_salary_func(bonus=0, taxes=0, penalty=0):

    def compute(salary):
        pre_bonus = (salary - penalty)
        pre_taxes = pre_bonus + pre_bonus * bonus
        return pre_taxes - pre_taxes * taxes

    return compute

salary_1 = get_salary_func(bonus=0.1, penalty=5000)
salary_2 = get_salary_func(bonus=0.1, taxes=0.2)
print(salary_1(100000))  # 104500.0
print(salary_2(100000))  #  88000.0</code></pre>


<h2>Inspecting Closures</h2>
<p>Python provides the special attributes <code>__closure__</code> and <code>__code__</code> to inspect
closures (see the <a href="https://docs.python.org/3/reference/datamodel.html">Data
Model</a> for details).</p>
<p>The variables a function has access to by enclosing an outer scope—so-called
<em>free variables</em>—can be retrieved as a tuple using the <code>co_freewars</code> attribute
of the <code>__code__</code> attribute. To get the values of those free variables, inspect
the <code>cell_contents</code> attribute of each element of the <code>__closure__</code> attribute:</p>
<pre class="codehilite"><code class="language-python">def get_salary_func(bonus=0, taxes=0, penalty=0):

    def compute(salary):
        pre_bonus = (salary - penalty)
        pre_taxes = pre_bonus + pre_bonus * bonus
        return pre_taxes - pre_taxes * taxes

    return compute

salary = get_salary_func(bonus=0.1, penalty=5000)
print(salary.__code__.co_freevars)  # ('bonus', 'penalty', 'taxes')
print(salary.__closure__[0].cell_contents)  # 0.1
print(salary.__closure__[1].cell_contents)  # 5000
print(salary.__closure__[2].cell_contents)  # 0</code></pre>


<p>This process can be simplified using an utility function:</p>
<pre class="codehilite"><code class="language-python">def get_salary_func(bonus=0, taxes=0, penalty=0):

    def compute(salary):
        pre_bonus = (salary - penalty)
        pre_taxes = pre_bonus + pre_bonus * bonus
        return pre_taxes - pre_taxes * taxes

    return compute

salary = get_salary_func(bonus=0.1, penalty=5000)

def inspect_closure(func):
    for i, name in enumerate(func.__code__.co_freevars):
        print(f'{name} = {func.__closure__[i].cell_contents}')

inspect_closure(salary)</code></pre>


<p>Which outputs all the free variables of a closure:</p>
<pre class="codehilite"><code>bonus = 0.1
penalty = 5000
taxes = 0</code></pre>


<p>Notice that those are read-only values, don't attempt to manipulate those
closures: better create a new one.</p>
<h1>Iterators</h1>
<p>An <em>iterator</em> can be used to process the elements of a sequence one by one. When
passed to the <code>next()</code> function, the next element of the iterator's underlying
sequence is returned—or <code>StopIteration</code> thrown, in case the iterator is
<em>exhausted</em>, i.e. all of its elements have been processed.</p>
<p>Higher-order functions like <code>filter</code> or <code>map</code> return iterators:</p>
<pre class="codehilite"><code class="language-python">numbers = [1, 2, 3, 4, 5]
even = filter(lambda x: x % 2 == 0, numbers)
odd = map(lambda x: x + 1, even)
print(next(odd))  # 3
print(next(odd))  # 5
print(next(odd))  # StopIteration</code></pre>


<p>An iterator can onle be processed once in forward direction. However, multiple
iterators can be used to process the same underlying sequence.</p>
<h2>Iterables</h2>
<p>An <em>iterable</em> is something (usually a sequence like list, tuple, string) that
can be turned into an iterator by passing it to the <code>iter()</code> function, which
returns a new iterator:</p>
<pre class="codehilite"><code class="language-python">numbers = [1, 2, 3]
i = iter(numbers)
print(next(i))  # 1
print(next(i))  # 2
print(next(i))  # 3</code></pre>


<p>An iterator itself is also an iterable, so calls to <code>iter()</code> passing an iterator
return the same iterator with its current state:</p>
<pre class="codehilite"><code class="language-python">numbers = [1, 2, 3]
i = iter(numbers)
print(next(i))  # 1
j = iter(i)
print(next(j))  # 2
print(next(i))  # 3</code></pre>


<h2>Loops use Iterators</h2>
<p>Internally, Python relies heavily on iterators. A <code>for</code>/<code>in</code> loop works on any
iterable. First, <code>iter()</code> is called on the loop's iterable to get an iterator.
Then, for every iteration, <code>next()</code> is called on the iterator to get to the next
elements. Finally, the loop ends when <code>StopIteration</code> is raised.</p>
<p>Consider this <code>for</code>/<code>in</code> loop:</p>
<pre class="codehilite"><code class="language-python">numbers = [1, 2, 3]

for x in numbers:
    print(x)</code></pre>


<p>Which could be re-written using explicit <code>iter()</code> and <code>next()</code> calls and a
<code>while</code> loop:</p>
<pre class="codehilite"><code class="language-python">numbers = [1, 2, 3]

i = iter(numbers)
while True:
    try:
        x = next(i)
        print(x)
    except StopIteration:
        break</code></pre>


<h2>Lazy Evaluation</h2>
<p>Iterators only must produce their values when requested using the <code>next()</code>
function, which means that they can use <em>lazy evaluation</em>. If an iteration is
stopped before the iterator has been exhausted, no remaining items have been
computed in vain. This can save computing power and memory, but potentially
increases the processing time needed for a single iteration. (Picking between
lazy and eager evaluation is a trade-off.) Iterators implemented using lazy
evaluation can be of infinite length.</p>
<p>The built-in <code>range()</code> function produces lazy sequences. However, the sequence's
length can be figured out using the built-in <code>len()</code> function considering the
limit arguments given to <code>range()</code>: <code>len(range(1, 5))</code> is <code>5 - 1 = 4</code>.</p>
<h2>Realizing Iterators</h2>
<p>An iterator must be <em>realized</em> before all of its items can be dealt with at
once, i.e. by printing out the whole sequence of items. For this purpose, the
according functions can be called:</p>
<pre class="codehilite"><code class="language-python">numbers = range(1, 4)

print(list(iter(numbers)))  # [1, 2, 3]
print(set(iter(numbers)))   # {1, 2, 3}
print(tuple(iter(numbers))) # (1, 2, 3)</code></pre>


<p>Alternatively, the expansion operator <code>*</code> can be used with according literals:</p>
<pre class="codehilite"><code class="language-python">numbers = range(1, 4)

print([*iter(numbers)])  # [1, 2, 3]
print({*iter(numbers)})  # {1, 2, 3}
print((*iter(numbers),)) # (1, 2, 3)</code></pre>


<p>Notice the trailing comma required for tuple expansion in the last example.</p>
<p>When working with strings, <code>str</code> will call the iterator's implementation of
the <code>__str__()</code> dunder method, which describes the iterator itself rather than
its items. Use the <code>join()</code> method on an empty string to realize a list of
characters:</p>
<pre class="codehilite"><code class="language-python">offsets = range(0, 26)
capital_a = 65
alphabet = map(lambda c: chr(c + capital_a), offsets)

print(str(alphabet))     # &lt;map object at 0x7fa5d875b4f0&gt;
print(''.join(alphabet)) # ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre>


<h2>Implementing an Iterator</h2>
<p>An iterator can be implemented by providing two dunder methods: <code>__next__()</code> and
<code>__iter__()</code>. Calls of the built-in functions <code>next()</code> and <code>iter()</code> will be
forwarded to the argument's respective dunder methods.</p>
<p>The class <code>Factorials</code> implements an iterator that provides the successive
factorial numbers up to a limit passed to the constructor. The implementation
uses lazy evaluation:</p>
<pre class="codehilite"><code class="language-python">class Factorials():

    def __init__(self, n):
        if n &lt; 0:
            raise ValueError('n! is only defined for n &gt;= 0')
        self.n = n
        self.i = 0
        self.x = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.i &lt; self.n:
            self.i += 1
            self.x *= self.i
            return self.x
        else:
            raise StopIteration


print(list(Factorials(3))) # [1, 2, 6]
print(list(Factorials(5))) # [1, 2, 6, 24, 120]
print(list(Factorials(8))) # [1, 2, 6, 24, 120, 720, 5040, 40320]</code></pre>


<p>In practice, <em>generators</em> are often a better fit for such tasks.</p>
<h1>Transforming Iterables</h1>
<p>Python provides functions to transform iterables, which are less prone to
side effects, and therefore the better fit than lists from a functional
perspective.</p>
<h2>Enumerating</h2>
<p>The built-in <code>enumerate()</code> function transforms a sequence into an iterator of
tuples, each containing an index value and an item from the original sequence:</p>
<pre class="codehilite"><code class="language-python">names = ['Alice', 'Bob', 'Mallory']
for item in enumerate(names):
    print(item)</code></pre>


<pre class="codehilite"><code>(0, 'Alice')
(1, 'Bob')
(2, 'Mallory')</code></pre>


<p>An optional start index can be provided, and the tuple can be unpacked using two
variables for the loop:</p>
<pre class="codehilite"><code class="language-python">names = ['Alice', 'Bob', 'Mallory']
for index, name in enumerate(names, 1):
    print(index, name)</code></pre>


<pre class="codehilite"><code>1 Alice
2 Bob
3 Mallory</code></pre>


<h2>Zipping and Unzipping</h2>
<p>Multiple sequences can be processed together using the built-in <code>zip()</code> function:</p>
<pre class="codehilite"><code class="language-python">names = ['Dilbert', 'Dogbert', 'Ashok']
jobs = ['Engineer', 'Consultant', 'Intern']
salaries = [120000, 250000, 18000]

for employee in zip(names, jobs, salaries):
    print(employee)</code></pre>


<pre class="codehilite"><code>('Dilbert', 'Engineer', 120000)
('Dogbert', 'Consultant', 250000)
('Ashok', 'Intern', 18000)</code></pre>


<p>Again, the tuple can be unpacked by using multiple variables for the loop:</p>
<pre class="codehilite"><code class="language-python">names = ['Dilbert', 'Dogbert', 'Ashok']
jobs = ['Engineer', 'Consultant', 'Intern']
salaries = [120000, 250000, 18000]

for name, job, salary in zip(names, jobs, salaries):
    print(name, job, salary)</code></pre>


<pre class="codehilite"><code>Dilbert Engineer 120000
Dogbert Consultant 250000
Ashok Intern 18000</code></pre>


<p>Notice that <code>zip()</code> stops when the shortest sequence is exhausted:</p>
<pre class="codehilite"><code class="language-python">names = ['Dilbert', 'Dogbert', 'Ashok']
jobs = ['Engineer']
salaries = [120000, 250000]

for employee in zip(names, jobs, salaries):
    print(employee)</code></pre>


<pre class="codehilite"><code>('Dilbert', 'Engineer', 120000)</code></pre>


<p>If the original sequences (<code>names</code>, <code>jobs</code>, <code>salaries</code>) are considered columns
of an employee database, the results of the <code>zip()</code> operation can be seen as its
rows. This transformation can be reversed using <code>zip()</code>—by first unpacking the
resulting sequence, and then zipping it:</p>
<pre class="codehilite"><code class="language-python">names = ['Dilbert', 'Dogbert', 'Ashok']
jobs = ['Engineer', 'Consultant', 'Intern']
salaries = [120000, 250000, 18000]

employees = zip(names, jobs, salaries)
for col in zip(*employees):
    print(col)</code></pre>


<pre class="codehilite"><code>('Dilbert', 'Dogbert', 'Ashok')
('Engineer', 'Consultant', 'Intern')
(120000, 250000, 18000)</code></pre>


<h2>Sorting and Reversing</h2>
<p>Unlike the list's <code>sort()</code> method that sorts a list in-place, the built-in
<code>sorted()</code> function returns a sorted new list. Either operation allows for an
optional <code>key</code> argument, which defines the sorting criterion in terms of a
function applied to every item:</p>
<pre class="codehilite"><code class="language-python">names = ['Dilbert', 'Dogbert', 'Ashok']
jobs = ['Engineer', 'Consultant', 'Intern']
salaries = [120000, 250000, 18000]
employees = zip(names, jobs, salaries)

for employee in sorted(employees, key=lambda e: e[2]):
    print(employee)</code></pre>


<pre class="codehilite"><code>('Ashok', 'Intern', 18000)
('Dilbert', 'Engineer', 120000)
('Dogbert', 'Consultant', 250000)</code></pre>


<p>The lambda accessing the tuple element at index 2 can also be taken from the
<code>operator</code> module, which provides an <code>itemgetter</code> function that produces a
closure to access the right element:</p>
<pre class="codehilite"><code class="language-python">from operator import itemgetter

names = ['Dilbert', 'Dogbert', 'Ashok']
jobs = ['Engineer', 'Consultant', 'Intern']
salaries = [120000, 250000, 18000]
employees = zip(names, jobs, salaries)

for employee in sorted(employees, key=itemgetter(2)):
    print(employee)</code></pre>


<pre class="codehilite"><code>('Ashok', 'Intern', 18000)
('Dilbert', 'Engineer', 120000)
('Dogbert', 'Consultant', 250000)</code></pre>


<p>When dealing with classes instead of tuple, use the <code>attrgetter</code> function to
access attributes by name. The <code>methodcaller</code> function allows to call any method
on each item by its name:</p>
<pre class="codehilite"><code class="language-python">from operator import methodcaller

names = ['POINTY HAIRED BOSS', 'Dilbert', 'dogbert', 'alice']
for name in sorted(names, key=methodcaller('lower')):
    print(name)</code></pre>


<p>Here, the <code>lower()</code> method is called on every name in order to sort the names in
a case-insensitive manner.</p>
<p>The sort order can be reversed either by setting the optional <code>reverse</code> argument
of the <code>sorted()</code> function to <code>True</code>, or by calling the <code>reversed()</code> built-in
function:</p>
<pre class="codehilite"><code class="language-python">names = ['Dilbert', 'Alice', 'Pointy Haired Boss', 'Dogbert', 'Ted']

names_desc = sorted(names, reverse=True)
print(names_desc)

names_desc = reversed(sorted(names))
print(list(names_desc))</code></pre>


<pre class="codehilite"><code>['Ted', 'Pointy Haired Boss', 'Dogbert', 'Dilbert', 'Alice']
['Ted', 'Pointy Haired Boss', 'Dogbert', 'Dilbert', 'Alice']</code></pre>


<p>Notice that the return value of <code>reversed()</code> needs to be realized first.</p>
<p>| Function     | accepts  | returns  |
|--------------|----------|----------|
| <code>sorted()</code>   | iterable | list     |
| <code>reversed()</code> | sequence | iterator |</p>
<p>The sorting operations are <em>stable</em>, so sorting multiple times will always
return the same order of items that share the same sorting criterion, but differ
otherwise:</p>
<pre class="codehilite"><code class="language-python"># Swiss-German date format
dates = [
    '24.06.1987',
    '13.05.1987',
    '31.12.1988',
    '31.07.1987',
    '17.09.1988',
    '05.02.1987',
    '01.03.1988',
]

by_year_1 = sorted(dates, key=lambda d: d[6:])
by_year_2 = sorted(by_year_1, key=lambda d: d[6:])
by_year_3 = sorted(by_year_2, key=lambda d: d[6:])
for date_1, date_2, date_3 in zip(by_year_1, by_year_2, by_year_3):
    print(date_1, '==', date_2, '==', date_3)</code></pre>


<pre class="codehilite"><code>24.06.1987 == 24.06.1987 == 24.06.1987
13.05.1987 == 13.05.1987 == 13.05.1987
31.07.1987 == 31.07.1987 == 31.07.1987
05.02.1987 == 05.02.1987 == 05.02.1987
31.12.1988 == 31.12.1988 == 31.12.1988
17.09.1988 == 17.09.1988 == 17.09.1988
01.03.1988 == 01.03.1988 == 01.03.1988</code></pre>


<p>When counting backwards, the <code>reverse()</code> function can be used to create more
readable code:</p>
<pre class="codehilite"><code class="language-python">range_reverse = range(9, -1, -1)     # hard to read
reversed_range = reversed(range(10)) # easy to read

for a, b in zip(range_reverse, reversed_range):
    print(a, b)</code></pre>


<pre class="codehilite"><code>9 9
8 8
7 7
6 6
5 5
4 4
3 3
2 2
1 1
0 0</code></pre>


<h2>Pipelines</h2>
<p>Adding <code>print()</code> calls to functions used with <code>filter()</code> and <code>map()</code> shows in
which order those functions are executed:</p>
<pre class="codehilite"><code class="language-python">def is_taxable(salary):
    print(f'is_taxable({salary})')
    return salary &gt; 100000

def calc_tax(salary):
    print(f'calc_tax({salary})')
    return salary * 0.05

salaries = [120000, 84000, 52000, 190000]
taxable = filter(is_taxable, salaries)
taxes = map(calc_tax, taxable)

for tax in taxes:
    print(tax)</code></pre>


<pre class="codehilite"><code>is_taxable(120000)
calc_tax(120000)
6000.0
is_taxable(84000)
is_taxable(52000)
is_taxable(190000)
calc_tax(190000)
9500.0</code></pre>


<p>Notice that those items are processed in a <em>pipeline</em> one by one. Even though
the call to <code>map()</code> comes after the call to <code>filter()</code>, the <code>is_taxable()</code>
operation used by <code>filter()</code> has only been processed for the first element yet!</p>
<p>Removing the <code>taxable</code> intermediary variable and calling <code>map()</code> directly on the
result of <code>filter()</code> therefore won't have any impact on the order of processing:</p>
<pre class="codehilite"><code class="language-python">def is_taxable(salary):
    print(f'is_taxable({salary})')
    return salary &gt; 100000

def calc_tax(salary):
    print(f'calc_tax({salary})')
    return salary * 0.05

salaries = [120000, 84000, 52000, 190000]
taxes = map(calc_tax, filter(is_taxable, salaries))

for tax in taxes:
    print(tax)</code></pre>


<pre class="codehilite"><code>is_taxable(120000)
calc_tax(120000)
6000.0
is_taxable(84000)
is_taxable(52000)
is_taxable(190000)
calc_tax(190000)
9500.0</code></pre>


<p>But leave the loop at the bottom away, and <em>no items will be processed at all</em>:</p>
<pre class="codehilite"><code class="language-python">def is_taxable(salary):
    print(f'is_taxable({salary})')
    return salary &gt; 100000

def calc_tax(salary):
    print(f'calc_tax({salary})')
    return salary * 0.05

salaries = [120000, 84000, 52000, 190000]
taxes = map(calc_tax, filter(is_taxable, salaries))
print(taxes)</code></pre>


<pre class="codehilite"><code>&lt;map object at 0x7fd3bbf03fd0&gt;</code></pre>


<p>This demonstrates that <code>filter()</code>, <code>map()</code> an the like use <em>lazy evaluation</em>.</p>
<h2>Multiple Map Parameters</h2>
<p>The <code>map()</code> function can be used on multiple sequences in one go—if used with a
function that expects the same number of arguments as sequences are used:</p>
<pre class="codehilite"><code class="language-python">numbers = [7, 4, 3, 2]
factors = [1.0, 1.5, 0.5, 2.0]

results = map(lambda n, f: n * f, numbers, factors)
print(list(results)) # [7.0, 6.0, 1.5, 4.0]</code></pre>


<p>Again, instead of defining a lambda, an <code>operator</code> can be used:</p>
<pre class="codehilite"><code class="language-python">from operator import mul

numbers = [7, 4, 3, 2]
factors = [1.0, 1.5, 0.5, 2.0]

results = map(mul, numbers, factors)
print(list(results)) # [7.0, 6.0, 1.5, 4.0]</code></pre>


<p>Any number of sequences can be passed to <code>map()</code>, as long as the operation
performed on them accepts the same number of parameters:</p>
<pre class="codehilite"><code class="language-python">def f(a, b, x):
    y = a * x + b
    return y

slopes = [1, 2, 3, 4]
coefficients = [1, 0, 2, 0]
xs = [1.5, 3.0, 2.5, 0.0]

results = map(f, slopes, coefficients, xs)
print(list(results)) # [2.5, 6.0, 9.5, 0.0]</code></pre>


<h1>Reducing Iterables</h1>
<p>A <em>reducing</em> function combines all the values of an iterable and produces a
single value out of them as a result.</p>
<h2>Built-in Reducing Functions</h2>
<p>the <code>len()</code> function is one of the most common reducing functions. It returns
the number of elements contained in an sequence:</p>
<pre class="codehilite"><code class="language-python">print(len([7, 3, 5, 2])) # 4
print(len([]))           # 0</code></pre>


<p>The <code>sum()</code> function adds up the items of an iterable and returns their sum:</p>
<pre class="codehilite"><code class="language-python">print(sum([7, 3, 5, 2])) # 17
print(sum([]))           #  0</code></pre>


<p>An optional start value can be provided for the second argument if the summation
should start from a different value than 0 (default):</p>
<pre class="codehilite"><code class="language-python">print(sum([7, 3, 5, 2], -10)) # 7
print(sum([], 0))             # 0</code></pre>


<p>Even though the <code>sum()</code> function applies the <code>+</code> operator to the elements of the
given iterable, it cannot be used to concatenate strings. Use the string's
<code>join()</code> method instead:</p>
<pre class="codehilite"><code class="language-python">letters = ['abc', 'de', 'f', 'ghi']
print(sum(letters, '')) # wrong: TypeError
print(''.join(letters)) # right: abcdefghi</code></pre>


<p>The <code>min()</code> and <code>max()</code> function return the smallest or biggest element of an
iterable, respectively:</p>
<pre class="codehilite"><code class="language-python">numbers = [7, 3, 1, 9, 5]
print(min(numbers)) # 1
print(max(numbers)) # 9</code></pre>


<p>If the elements are list themselves, those sub-lists are compared element-wise:</p>
<pre class="codehilite"><code class="language-python">numbers = [[3, 1, 2], [9, 1, 3], [1, 9, 8]]
print(min(numbers)) # [1, 9, 8]
print(max(numbers)) # [9, 1, 3]</code></pre>


<p>Calling <code>min()</code> or <code>max()</code> on an empty iterable causes a <code>ValueError</code>, which can
be prevented by setting a <code>default</code> argument, which is used as a fallback, and
ignored for non-empty iterables:</p>
<pre class="codehilite"><code class="language-python">numbers = [9, 1, 5]
nothing = []

print(min(numbers))            # 1
print(min(numbers, default=0)) # 1
print(min(nothing))            # ValueError
print(min(nothing, default=0)) # 0

print(max(numbers))            # 9
print(max(numbers, default=0)) # 9
print(max(nothing))            # ValueError
print(max(nothing, default=0)) # 0</code></pre>


<p>The optional <code>key</code> argument can be used to speficy the criterion being used for
comparison—like for the <code>sorted()</code> function or <code>sort()</code> method:</p>
<pre class="codehilite"><code class="language-python">employees = [
    ('Dilbert', 42, 120000),
    ('Alice', 39, 110000),
    ('Wally', 53, 130000),
    ('Ashok', 23, 36000),
]

youngest = min(employees, key=lambda e: e[1])
oldest = max(employees, key=lambda e: e[1])

lowest_salary = min(employees, key=lambda e: e[2])
highest_salary = max(employees, key=lambda e: e[2])

print(f'age: {youngest} (youngest), {oldest} (oldest)')
print(f'earns: {lowest_salary} (least), {highest_salary} (most)')</code></pre>


<pre class="codehilite"><code>age: ('Ashok', 23, 36000) (youngest), ('Wally', 53, 130000) (oldest)
earns: ('Ashok', 23, 36000) (least), ('Wally', 53, 130000) (most)</code></pre>


<p>The <code>any()</code> function returns <code>True</code> if <em>at least one element</em> of the given
iterable evaluates to <code>True</code>:</p>
<pre class="codehilite"><code class="language-python">print(any([False, False, False])) # False
print(any([False, False, True]))  # True
print(any([0, 0, 0, 0, 0]))       # False
print(any([0, 0, 0, 1, 0]))       # True
print(any(['', '', '', '']))      # False
print(any(['', 'x', '', 'y']))    # True
print(any([False, '', 0, []]))    # False
print(any([]))                    # False</code></pre>


<p>For an empty iterable (last example), <code>any()</code> returns False—unlike the <code>all()</code>
function, which returns <code>True</code> if <em>all elements</em> evaluate to <code>True</code>, and
<code>False</code>, if an element evaluates to <code>False</code>:</p>
<pre class="codehilite"><code class="language-python">print(all([True, False, True]))  # False
print(all([True, True, True]))   # True
print(all([2, 8, 0, 3, 8]))      # False
print(all([2, 8, 4, 3, 8]))      # True
print(all(['a', 'b', '', 'd']))  # False
print(all(['u', 'v', 'x', 'y'])) # True
print(all([True, 'a', 1, []]))   # False
print(all([]))                   # True</code></pre>


<h2>The <code>reduce()</code> Function</h2>
<p>The <code>functools</code> module provides a <code>reduce()</code> function, which allows for custom
definitions of reducing operations. Its first argument is a function accepting
<em>two</em> parameters (the elements <code>n-1</code> and <code>n</code> to be combined), and its second
argument is the iterable to be reduced. This example implements factorials using
the <code>operator</code> module's <code>mul()</code> and the <code>functool</code> module's <code>reduce()</code> function:</p>
<pre class="codehilite"><code class="language-python">from functools import reduce
from operator import mul

def factorial(x):
    numbers = range(1, x+1)
    return reduce(mul, numbers)

print(factorial(4)) #  24
print(factorial(5)) # 120
print(factorial(6)) # 720</code></pre>


<p>As an optional third argument, an <code>initializer</code> can be provided:</p>
<pre class="codehilite"><code class="language-python">from functools import reduce
from operator import mul

numbers = range(1, 6)
half_the_fac = reduce(mul, numbers, 0.5)
print(half_the_fac) # 60.0</code></pre>


<p>This is especially useful when dealing with empty iterables, which result in a
<code>TypeError</code> when reduced without an initializer, which serves as a fallback
value:</p>
<pre class="codehilite"><code class="language-python">from functools import reduce
from operator import mul

print(reduce(mul, []))      # TypeError
print(reduce(mul, [], 0.5)) # 0.5</code></pre>


<h2>The <code>filter()</code>, <code>map()</code>, <code>reduce()</code> Pattern</h2>
<p>Even though they work completely different, the functions <code>filter()</code>, <code>map()</code>,
and <code>reduce()</code> have some pair-wise commonalities:</p>
<ul>
<li>Both <code>filter()</code> and <code>map()</code> process the elements of an iterable one by one.</li>
<li>Both <code>map()</code> and <code>reduce()</code> transform values.</li>
<li>Both <code>filter()</code> and <code>reduce()</code> decrease the number of elements.</li>
</ul>
<p>Those three functions are often used together to process iterables, resulting in
a single value. Consider the following list containing employees, their hourly
rates, and the amount of hours worked by each for a project:</p>
<pre class="codehilite"><code class="language-python">efforts = [
    # (name, rate, hours)
    ('Dilbert', 220, 13.5),
    ('Alice', 180, 16.0),
    ('Wally', 150, 0.0),
    ('Ashok', 80, 42.5),
    ('Dogbert', 250, 3.5),
    ('Pointy Haired Boss', 500, 0.0),
]</code></pre>


<p>In order to produce the total labor costs of the project, this list of tuples
can be processed in three steps:</p>
<ol>
<li><em>filter</em>: Only entries with actual working hours (&gt; 0.0) are retained.</li>
<li><em>map</em>: Compute the cost for each employee (rate multiplied by hours).</li>
<li><em>reduce</em>: Sum up all the individual costs of each employee.</li>
</ol>
<pre class="codehilite"><code class="language-python">from functools import reduce
from operator import add

efforts = [
    # (name, rate, hours)
    ('Dilbert', 220, 13.5),
    # ...
]

involved = filter(lambda e: e[2] &gt; 0.0, efforts)
cost_per_employee = map(lambda e: e[1] * e[2], involved)
total_costs = reduce(add, cost_per_employee)
print(f'total costs: {total_costs}') # 10125.0</code></pre>


<p>In this particular example, the <code>filter</code> step is redundant, because employees
with zero hours would not affect the total cost at all. The <code>reduce</code> step could
also be simplified using the <code>sum()</code> function:</p>
<pre class="codehilite"><code class="language-python">efforts = [
    # (name, rate, hours)
    ('Dilbert', 220, 13.5),
    # ...
]

cost_per_employee = map(lambda e: e[1] * e[2], efforts)
total_costs = sum(cost_per_employee)
print(f'total costs: {total_costs}') # 10125.0</code></pre>


<p>Consider another example: a list of exam submissions consisting of the name, the
submission date, and the score achieved:</p>
<pre class="codehilite"><code class="language-python">submissions = [
    # name, submission date, score
    ('Alice', '2021-07-03', 73),
    ('Bob', '2021-07-18', 81),
    ('Charles', '2021-07-12', 57),
    ('Deborah', '2021-07-10', 96),
    ('Ernest', '2021-07-19', 89),
    ('Fanny', '2021-07-06', 61),
]</code></pre>


<p>The average grade of submissions within deadline should be computed as follows:</p>
<ol>
<li><em>filter</em>: Submissions after the deadline (<code>2021-07-10</code>) are ignored.</li>
<li><em>map</em>: A grade from 1 (worst) to 6 (best) is computed based on a maximum
   score of 100.</li>
<li><em>reduce</em>: The grade average of all submissions is calculated.</li>
</ol>
<pre class="codehilite"><code class="language-python">from datetime import datetime

submissions = [
    # name, submission date, score
    ('Alice', '2021-07-03', 73),
    # ...
]

max_score = 100

def is_within_deadline(submission):
    deadline = datetime.fromisoformat('2021-07-10')
    submitted = datetime.fromisoformat(submission[1])
    return submitted &lt; deadline

def swiss_grade(score, max_score):
    return score / max_score * 5 + 1

within_deadline = filter(is_within_deadline, submissions)
grades = map(lambda s: swiss_grade(s[2], max_score), within_deadline)
grades = list(grades)
average = sum(grades) / len(grades)
print(f'average: {average}') # 4.35</code></pre>


<h1>Comprehensions</h1>
<p>Creating an iterable based on another iterable, say, building the squares of a
list of numbers, can be done in various ways.</p>
<p>The structured approach uses a <code>for</code> loop:</p>
<pre class="codehilite"><code class="language-python">numbers = range(1, 10)

squares = []
for number in numbers:
    squares.append(number ** 2)

print(squares) # [1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre>


<p>This approach is perfectly valid, but requires <em>operational reasoning</em> to
understand.</p>
<p>A more declarative approach uses the higher-order <code>map</code> function, which requires
less code to be written:</p>
<pre class="codehilite"><code class="language-python">numbers = range(1, 10)

squares = list(map(lambda x: x ** 2, numbers))

print(squares) # [1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre>


<p>However, the best tool for this purpose—building a list based on an iterable—is
a list comprehension:</p>
<pre class="codehilite"><code class="language-python">numbers = range(1, 10)

squares = [x ** 2 for x in numbers]

print(squares) # [1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre>


<p>No lambda expression is required, the expression can be stated directly.</p>
<p>The comprehension has the following structure:</p>
<pre class="codehilite"><code>[{expression} for {item} in {iterable}]</code></pre>


<p>The above example can be read in English as:</p>
<blockquote>
<p>make a list of <code>x ** 2</code> for all values of <code>x</code> in <code>numbers</code></p>
</blockquote>
<h2>Conditions</h2>
<p>The higher-order functinos <code>filter</code> and <code>map</code> are often used toghether: first,
the items to be processed are fitered, second, the remaining items are mapped.</p>
<p>Consider this example turning a list of empty and non-empty strings into
title-cased strings, ignoring the empty ones:</p>
<pre class="codehilite"><code class="language-python">strings = ['', '', 'john', '', 'alice', '', 'bob']
non_empty = filter(len, strings)
names = list(map(lambda s: s.title(), non_empty))
print(names) # ['John', 'Alice', 'Bob']</code></pre>


<p>A comprehension has an optional <code>if</code> statements; only items passing this test
end up in the resulting sequence:</p>
<pre class="codehilite"><code class="language-python">strings = ['', '', 'john', '', 'alice', '', 'bob']
names = [s.title() for s in strings if s]
print(names) # ['John', 'Alice', 'Bob']</code></pre>


<p>This code is shorter and clearer. Consider a comprehension as an alternative of
combining <code>filter</code> and <code>map</code>.</p>
<h2>Nesting</h2>
<p>Comprehensions can be nested, which can be used to create multi-dimensional
lists:</p>
<pre class="codehilite"><code class="language-python">def field_2d(rows, cols):
    return [[(x, y) for x in range(cols)] for y in range(rows)]

field = field_2d(6, 7)
for row in field:
    print(row)</code></pre>


<pre class="codehilite"><code>[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)]
[(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1)]
[(0, 2), (1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)]
[(0, 3), (1, 3), (2, 3), (3, 3), (4, 3), (5, 3), (6, 3)]
[(0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4), (6, 4)]
[(0, 5), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5)]</code></pre>


<p>Again, this is much shorter than using the structured approach:</p>
<pre class="codehilite"><code class="language-python">def field_2d(rows, cols):
    field = []
    for y in range(rows):
        row = []
        for x in range(cols):
            row.append((x, y))
        field.append(row)
    return field</code></pre>


<p>Notice that comprehensions can be nested without creating multi-dimensional
sequences as a result:</p>
<pre class="codehilite"><code class="language-python">coords = [x + y for x in range(0, 40, 10) for y in range(4)]
print(coords)</code></pre>


<pre class="codehilite"><code>[0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23, 30, 31, 32, 33]</code></pre>


<p>This translates to structured code as follows:</p>
<pre class="codehilite"><code class="language-python">coords = []
for x in range(0, 40, 10):
    for y in range(4):
        coords.append(x + y)</code></pre>


<p>In the comprehension expression, the inner loop is on the right, the outer loop
on the left.</p>
<h2>Dictionaries, Sets, Tuples</h2>
<p>Comprehensions can be used for the other sequence types—dictionaries, sets,
and tuples—too:</p>
<pre class="codehilite"><code class="language-python">squares = {x: x ** 2 for x in range(1, 6)}
print(squares) # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

additions = [(3, 4), (4, 3), (5, 2), (3, 1), (4, 2)]
sums = {x + y for (x, y) in additions}
print(sums) # {4, 6, 7}

strings = ['', '', 'john', '', 'alice', '', 'bob']
names = tuple(s.title() for s in strings if s)
print(names) # ('John', 'Alice', 'Bob')</code></pre>


<p>Notice that the last example creates a <em>generator object</em>, which must explicitly
be converted to a tuple.</p>
<h1>Generators</h1>
<p>Unlike comprehensions, <em>generators</em> use lazy evaluation. Unlike iterators,
generators do not require implementing a class implementing the <code>next()</code> and
<code>iter()</code> method (less boilerplate).</p>
<p>Generators are implemented using functions that yield a different result every
time they are called:</p>
<pre class="codehilite"><code class="language-python">def squares(n):
    for i in range(n):
        yield i ** 2

print(list(squares(6))) # [0, 1, 4, 9, 16, 25]</code></pre>


<p>After a value is returned using the <code>yield</code> keyword, the generator function
stops its execution, but its state is remembered. The execution is continued for
the next iteration. This makes it possible for generator functions to hold a
state (without using an explicit closure):</p>
<pre class="codehilite"><code class="language-python">def factorials(n):
    current = 1
    for i in range(n):
        if i != 0:
            current *= i
        yield current

print(list(factorials(6))) # [1, 1, 2, 6, 24, 120]</code></pre>


<p>As seen in the last example of the previous chapter, a generator can be created
as a comprehension using parentheses:</p>
<pre class="codehilite"><code class="language-python">square_gen = (x ** 2 for x in range(2, 6))
print(next(square_gen)) #  4
print(next(square_gen)) #  9
print(next(square_gen)) # 16
print(next(square_gen)) # 25
print(next(square_gen)) # StopIteration</code></pre>


<p>Generators combine the advantages of comprehensions with lazy evaluation. If a
sequence is hard to express in terms of <code>filter</code> and <code>map</code>, and if the task is
memory-critical, consider a generator.</p>
<h1>Partial Application and Currying</h1>
<p><em>Partial application</em> of functions and <em>currying</em> are both ways to create new
functions based on existing functions. Those techniques are based on closures. (A
closure is an inner function returned from a surrounding function, with the
inner function having references to the surrounding function.)</p>
<h2>Partial Application</h2>
<p>With partial application, only a subset of a function's parameters are set on
the first function call. The rest of the parameters are filled in a later call
to the partially applied function.</p>
<p>Consider the function <code>inc_x</code>, which requires a parameter <code>x</code>, and returns a
function that increases its parameter by <code>x</code>:</p>
<pre class="codehilite"><code class="language-python">def inc_x(x):
    def inc(y):
        return x + y
    return inc

numbers = [1, 2, 3]

inc_1 = inc_x(1)
inc_3 = inc_x(3)

print(list(map(inc_1, numbers))) # [2, 3, 4]
print(list(map(inc_3, numbers))) # [4, 5, 6]</code></pre>


<p>Partial application is especially helpful if a function has a lot of parameters,
like a quadratic function:</p>
<pre class="codehilite"><code>y = ax² + bx + c</code></pre>


<p>Such a function is usually defined in terms of the parameters <code>a</code>, <code>b</code>, and
<code>c</code>—and applied multiple times using different values for <code>x</code>:</p>
<pre class="codehilite"><code class="language-python">def quad(a, b, c, x):
    return a*x**2 + b*x + c

def quad_abc(a, b, c):
    def f(x):
        return quad(a, b, c, x)
    return f

xs = range(5)

f = quad_abc(1, 2, 3)
g = quad_abc(2, 0, 1)

print(list(map(f, xs))) # [3, 6, 11, 18, 27]
print(list(map(g, xs))) # [1, 3, 9, 19, 33]</code></pre>


<p>The <code>partial()</code> functions from the <code>functools</code> module provides a more flexible
approach that doesn't require defining closures for specific partial
applications. The code above can be simplified using <code>partial()</code>:</p>
<pre class="codehilite"><code class="language-python">from functools import partial

def quad(a, b, c, x):
    return a*x**2 + b*x + c

xs = range(5)

f = partial(quad, 1, 2, 3)
g = partial(quad, 2, 0, 1)

print(list(map(f, xs))) # [3, 6, 11, 18, 27]
print(list(map(g, xs))) # [1, 3, 9, 19, 33]</code></pre>


<p>It is possible to apply a function partially multiple times, until every
parameter was filled in:</p>
<pre class="codehilite"><code class="language-python">from functools import partial

def quad(a, b, c, x):
    return a*x**2 + b*x + c

xs = range(5)

quad_a = partial(quad, 1)
quad_ab = partial(quad_a, 2)
quad_abc = partial(quad_ab, 3)

print(list(map(quad_abc, xs))) # [3, 6, 11, 18, 27]</code></pre>


<p>However, using partial application, the parameters have to be filled in the
order as they are defined in the function. It's not possible to just define
the <code>quad</code> function's parameter <code>b</code> and <code>x</code>, and leave <code>a</code> and <code>c</code> undefined.</p>
<p>It is possible though to partially apply a function by setting keyword
arguments:</p>
<pre class="codehilite"><code class="language-python">from functools import partial

print_csv = partial(print, sep=',')
print_space = partial(print, sep=' ')

names = ['Dilbert', 'Alice', 'Wally']
print_csv(*names)   # Dilbert,Alice,Wally
print_space(*names) # Dilbert Alice Wally</code></pre>


<h2>Currying</h2>
<p>Python supports currying using third-party libraries such as PyMonad (version
2.4.0):</p>
<pre class="codehilite"><code>$ pip install --user PyMonad==2.4.0</code></pre>


<p>The <code>pymonad</code> module includes the <code>curry</code> decorator, which can be used to define
functions that can be partially applied without explicit use of
<code>functools.partial</code>. The number of arguments to be curried needs to be passed to
the <code>curry</code> decorator:</p>
<pre class="codehilite"><code class="language-python">from pymonad.tools import curry

@curry(4)
def quad(a, b, c, x):
    return a*x**2 + b*x + c

xs = range(5)

quad_abc = quad(1, 2, 3)
print(list(map(quad_abc, xs))) # [3, 6, 11, 18, 27]

quad_a = quad(1)
quad_ab = quad_a(2)
quad_abc = quad_ab(3)
print(list(map(quad_abc, xs))) # [3, 6, 11, 18, 27]</code></pre>


<p>Notice that curried functions don't come for free; a lot of functions with
different argument lists are defined automatically in the background. Calling a
curried function is less explicit than using partial application. Make sure the
curried nature of a function is made clear to its users by the means of naming,
documentation, or convention (writing a module where functions are curried in
general).</p>
<h2>Advanced Composition</h2>
<p>Functions with a single argument can be composed using a closure:</p>
<pre class="codehilite"><code class="language-python">def compose(f, g):
    def fn(x):
        return f(g(x))
    return fn

def increment(x):
    return x + 1

def twice(x):
    return x * 2

f = compose(twice, increment)

print(f(1)) # 4
print(f(2)) # 6
print(f(3)) # 8</code></pre>


<p>Functions with multiple arguments can only be composed as above if partially
applied before to turn them into functions accepting a single argument:</p>
<pre class="codehilite"><code class="language-python">from functools import partial

def compose(f, g):
    def fn(x):
        return f(g(x))
    return fn

def add(x, y):
    return x + y

def mul(x, y):
    return x * y

increment = partial(add, 1)
twice  = partial(mul, 2)
f = compose(twice, increment)

print(f(1)) # 4
print(f(2)) # 6
print(f(3)) # 8</code></pre>


<h3>Composing Multiple Functions</h3>
<p>Consider the following set of functions <code>f()</code>, <code>g()</code>, <code>h()</code>, and <code>i()</code>, which
perform the following computations:</p>
<ul>
<li><code>f(x)</code>: adds 1 to <code>x</code></li>
<li><code>g(x)</code>: multiplies <code>x</code> by 2</li>
<li><code>h(x)</code>: computes <code>x</code> to the power of 3</li>
<li><code>i(x)</code>: subtracts 1 from <code>x</code></li>
</ul>
<p>Thus, <code>i(h(g(f(x)))) = (((x + 1) * 2) ^ 3) - 1</code>. Composing those functions one
by one is cumbersome:</p>
<pre class="codehilite"><code class="language-python">def compose(f, g):
    def fn(x):
        return f(g(x))
    return fn

def f(x):
    return x + 1

def g(x):
    return x * 2

def h(x):
    return x ** 3

def i(x):
    return x - 1

fn = compose(i, h)
fn = compose(fn, g)
fn = compose(fn, f)

print(fn(1)) # (((1 + 1) * 2) ^ 3) - 1 = 63</code></pre>


<p>The composition can be generalized as a reducing operation. The <code>compose()</code>
function accepts a list of functions to be reduced by composing them pair-wise:</p>
<pre class="codehilite"><code class="language-python">from functools import reduce

def compose(*fns):
    def compose_pair(f, g):
        def fn(x):
            return f(g(x))
        return fn
    return reduce(compose_pair, fns)

def f(x):
    return x + 1

def g(x):
    return x * 2

def h(x):
    return x ** 3

def i(x):
    return x - 1

fn = compose(i, h, g, f)

print(fn(1)) # (((1 + 1) * 2) ^ 3) - 1 = 63</code></pre>


<p>Unfortunately, this implementation doesn't work if <em>no</em> functions are passed as
arguments. The <code>initializer</code> argument of <code>reduce()</code> can be used to define a
default value. A sensible default value, however, depends on the operation to be
performed. (For an addition or subtraction, the neutral element is 0, for a
multiplicationor a division, the neutral element is 1.) The <em>identity value</em>
provided by an <em>identity function</em> (<code>lambda x: x</code>) is the right choice for all
cases:</p>
<pre class="codehilite"><code class="language-python">from functools import reduce

def compose(*fns):
    def compose_pair(f, g):
        def fn(x):
            return f(g(x))
        return fn
    return reduce(compose_pair, fns, lambda x: x)

fn = compose()
print(fn(37)) # 37</code></pre>


<h1>Functors and Monads</h1>
<p>Functors wrap a value and control how functions are applied to that wrapped
value. Such wrappers are useful when dealing with values that might be missing,
or add new capabilities to existing functions, such as making a function
that can only deal with scalar values capable of handling lists of scalar
values.</p>
<p>The <code>oslash</code> library provides Haskell-style <em>functors</em>, <em>applicatives</em>, and
<em>monads</em>:</p>
<pre class="codehilite"><code>$ pip install oslash==0.6.3</code></pre>


<ul>
<li>A <strong>functor</strong> wraps a value and controls how function is applied to that
  wrapped value using the <code>map()</code> method or the <code>%</code> operator.</li>
<li>An <strong>applicative</strong> is a special kind of a functor that wraps a function, which
  can be called by the <code>apply()</code> method.</li>
<li>A <strong>monad</strong> is a special kind of an applicative that also wraps the value
  returned from a function using its <code>bind()</code> method.</li>
</ul>
<p>Those constructs are crucial in a pure functional programming language like
Haskell, where they are needed to deal with errors or side-effects. In Python,
those constructs are optional—hence available by third-party libraries such as
<code>oslash</code>—and can be left away in favour of procedural code.</p>
<h2>Functors</h2>
<p>The <code>Just</code> functor, which technically is also an applicative and a monad (of
which more later), is a wrapper around a value:</p>
<pre class="codehilite"><code class="language-python">from oslash import Just

x = Just(3)
print(x) # Just 3</code></pre>


<p>Functions cannot be called directly with an instance of <code>Just</code> as an argument.
Instead, the functor's <code>map()</code> method or the <code>%</code> operator can be used:</p>
<pre class="codehilite"><code class="language-python">from oslash import Just

def twice(x):
    return x * 2

x = Just(3)

y = twice(x) # illegal

y = x.map(twice) # correct
print(y) # Just 6

y = twice % x # correct, but shorter
print(y) # Just 6</code></pre>


<p>Notice that the function stands at the left of the <code>%</code> operator, and the functor
to its right.</p>
<p>The <code>Nothing</code> functor does not wrap a value. It is the functional brother of
Python's <code>None</code> with well-defined behaviour—a function being applied to
<code>Nothing</code> always returns <code>Nothing</code> instead of throwing an exception:</p>
<pre class="codehilite"><code class="language-python">from oslash import Nothing

def twice(x):
    return x * 2

x = Nothing()
print(x) # Nothing

y = twice % x
print(y) # Nothing</code></pre>


<p>The <code>List</code> functor wraps a list of values and makes it possible that a function
that only deals with scalar values can be applied to an entire list—a lot like
the higher-order <code>map()</code> function (notice that the <code>twice()</code> function has to be
wrapped by a <code>Just</code> functor, of which more in the next section):</p>
<pre class="codehilite"><code class="language-python">from oslash import Just, List

def twice(x):
    return x * 2

xs = List.from_iterable([1, 2, 4, 8]) # [1, 2, 4, 8]
print(xs)

f = Just(twice)

ys = f.apply(xs) # [2, 4, 8, 16]
print(ys)</code></pre>


<h2>Applicatives</h2>
<p>The <code>Just</code> functor is, in fact, also an <em>applicative functor</em> that wraps a
function as a value, or short: an applicative, which provides an <code>apply()</code>
method:</p>
<pre class="codehilite"><code class="language-python">from oslash import Just

def twice(x):
    return x * 2

x = Just(3)
f = Just(twice)

b = f.apply(x)
print(b) # Just 6</code></pre>


<p>Notice that both the value <code>3</code> and the function <code>twice()</code> have been wrapped by a
<code>Just</code> applicative.</p>
<p>An applicative wrapping a function with more than one parameter returns a
partially applied function if the <code>apply()</code> method is called on it. The
arguments can be filled in one by one:</p>
<pre class="codehilite"><code class="language-python">from oslash import Just

def quad(a, b, c, x):
    return (a * x ** 2) + b * x + c

f = Just(quad)
f_a = f.apply(Just(1))
f_ab = f_a.apply(Just(2))
f_abc = f_ab.apply(Just(3))

x = Just(4)

y = f_abc.apply(x)
print(y) # Just 27

y = Just(quad).apply(Just(1)).apply(Just(2)).apply(Just(3)).apply(x)
print(y) # Just 27</code></pre>


<h2>Monads</h2>
<p>An applicative that also wraps the return value resulting from a call to its 
wrapped function is called a monad. Its <code>bind()</code> method accepts a single
parameter—a function returning another monad:</p>
<pre class="codehilite"><code class="language-python">from oslash import Just, Nothing

def safe_reciprocal(x):
    if x == 0:
        return Nothing()
    return Just(1/x)

x = Just(4)
y = x.bind(safe_reciprocal)
print(y) # Just 0.25

x = Just(0)
y = x.bind(safe_reciprocal)
print(y) # Nothing</code></pre>


<h1>Useful Libraries</h1>
<p>Python's standard library offers a lot of capabilities that support a functional
programming style. The <code>functools</code> (treated above) and <code>itertools</code> (treated in
the following section) modules are especially useful for that purpose.</p>
<h2>The <code>itertools</code> Module</h2>
<p>The <code>itertools</code> module provides useful functions to create iterators.</p>
<p>Infinite series of incrementing values can be created using the <code>count()</code>
function, which requires a <code>start</code> value and an optional <code>step</code> size:</p>
<pre class="codehilite"><code class="language-python">from itertools import count

to_infinite = count(0) # 0, 1, 2, 3, ...
to_infinite = count(0, 10) # 0, 10, 20, 30, ...</code></pre>


<p>Infinite or finite repetitions of values can be created using the <code>repeat()</code>
function, which requires a value <code>x</code> to be repeated and an optional limit <code>n</code>:</p>
<pre class="codehilite"><code class="language-python">from itertools import repeat

infinite_ones = repeat(1) # 1, 1, 1, 1, ...
limited_ones = repeat(1, 3) # 1, 1, 1</code></pre>


<p>Series of numbers can be repeated using the <code>cycle()</code> function that accepts an
iterator to be repeated:</p>
<pre class="codehilite"><code class="language-python">from itertools import cycle

one_two_three_ad_nauseam = cycle([1, 2, 3]) # 1, 2, 3, 1, 2, 3</code></pre>


<p>Like <code>zip</code>, the <code>zip_longest</code> function zips together two iterables. Unlike
<code>zip</code>, it doesn't stop when the shorter iterable is exhausted, but fills in
values until the longer iterable is exhausted, too:</p>
<pre class="codehilite"><code class="language-python">from itertools import zip_longest

names = ['Dilbert', 'Alice', 'Wally']
ranks = range(1, 6)
ranking = zip_longest(ranks, names, fillvalue='fired')
for rank in ranking:
    print(rank)</code></pre>


<pre class="codehilite"><code>(1, 'Dilbert')
(2, 'Alice')
(3, 'Wally')
(4, 'fired')
(5, 'fired')</code></pre>


<p>If a function with <code>n</code> parameters is given to the higher-order <code>map()</code> function,
it expects <code>n</code> iterables, too. The higher-order <code>starmap()</code> requires a single
iterable consisting of <code>n</code> tuples instead:</p>
<pre class="codehilite"><code class="language-python">from itertools import starmap

inventory = [
    (17, 0.99),
    (32, 0.49),
    (12, 5.49),
    (97, 0.19),
    (13, 2.95),
]

positions = starmap(lambda n, p: n * p, inventory)

for position in positions:
    print(position)</code></pre>


<pre class="codehilite"><code>16.83
15.68
65.88
18.43
38.35</code></pre>


<p>The <code>filterfalse()</code> higher-order function works like <code>filter()</code>, except that it
returns the values for which the predicate function returns <code>False</code>:</p>
<pre class="codehilite"><code class="language-python">from itertools import filterfalse

def is_even(x):
    return x % 2 == 0

numbers = range(10)
even = filter(is_even, numbers)
odd = filterfalse(is_even, numbers)

print(list(even)) # [0, 2, 4, 6, 8]
print(list(odd))  # [1, 3, 5, 7, 9]</code></pre>


<p>The <code>accumulate()</code> function works like <code>sum()</code>, but keeps a running total:</p>
<pre class="codehilite"><code class="language-python">from itertools import accumulate

xs = range(5)
sums = accumulate(xs)

print(list(xs))   # [0, 1, 2, 3, 4]
print(list(sums)) # [0, 1, 3, 6, 10]</code></pre>


<p>Two or more iterables can be joined together using the <code>chain()</code> function:</p>
<pre class="codehilite"><code class="language-python">from itertools import chain

xs = range(3)
ys = range(3, 6)
zs = range(6, 9)

print(list(chain(xs, ys, zs))) # [0, 1, 2, 3, 4, 5, 6, 7, 8]</code></pre>


<p>An iterable can be turned into <code>n</code> iterables with the same underlying values
using the <code>tee()</code> function:</p>
<pre class="codehilite"><code class="language-python">from itertools import tee

xs = range(5)

a, b, c = tee(xs, 3)
print(list(a)) # [0, 1, 2, 3, 4]
print(list(b)) # [0, 1, 2, 3, 4]
print(list(c)) # [0, 1, 2, 3, 4]</code></pre>


<p>The <code>takewhile()</code> function works like <code>filter()</code>, but stops after the first item
fails the predicate function. The <code>dropwhile()</code> function ignores values until
the first item matches the predicate function:</p>
<pre class="codehilite"><code class="language-python">from itertools import takewhile, dropwhile

def is_even(x):
    return x % 2 == 0

numbers = [0, 2, 4, 6, 7, 8, 10, 11]

left = takewhile(is_even, numbers)
right = dropwhile(is_even, numbers)

print(list(left))  # [0, 2, 4, 6]
print(list(right)) # [7, 8, 10, 11]</code></pre>


<p>Notice that the value <code>11</code> is included in the <code>right</code> list, even though it
wouldn't match the <code>is_even()</code> predicate function.</p>
<p>See the <a href="https://docs.python.org/3/library/itertools.html"><code>itertools</code></a> and
<a href="https://docs.python.org/3/library/functools.html"><code>functools</code></a> documentation
pages for more details and additional useful functions.</p>
<h2>Third-Party Libraries</h2>
<p>The following third-party libraries have been introduced in this text:</p>
<ul>
<li><a href="https://pypi.org/project/PyMonad/">PyMonad</a> providing functional programming
  techniques the Python standard library doesn't.</li>
<li><a href="https://pypi.org/project/OSlash/">OSlash</a> providing functors, applicatives,
  and monads.</li>
</ul></div>
    </body>
</html>